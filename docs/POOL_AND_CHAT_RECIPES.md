# Пул рецептов и сохранение блюд из чата

## 1. Что считается пулом в БД

**Пул рецептов** — это таблица **`public.recipes`** в Supabase (ваш проект → Table Editor → `recipes`).

Выборка для пула (в Edge Function `generate-plan`, функция `pickFromPool`):

- **Таблица:** `public.recipes`
- **Условия:**
  - `user_id = auth.uid()` (рецепты текущего пользователя)
  - `source IN ('seed', 'starter', 'manual', 'week_ai', 'chat_ai')`
- **Сортировка:** `created_at DESC`
- **Лимит кандидатов:** 60 (затем фильтрация по типу приёма, аллергиям и т.д.)

То есть пул — это **все рецепты пользователя** с указанными источниками, без привязки к схеме/базе по «адресу»: используется обычный Supabase-клиент `.from("recipes")` (схема `public` по умолчанию).

---

## 2. Как для профиля выбирается блюдо из пула

Для **конкретного профиля** (член семьи или «Семья») логика такая.

### 2.1. Фильтр по `member_id`

- **План «Семья»** (`member_id` плана = `null`):
  - **Было:** в пул попадали только рецепты с `recipes.member_id IS NULL`.
  - **Стало:** в пул для «Семья» попадают **все рецепты пользователя** (без фильтра по `member_id`), чтобы и рецепты, сохранённые в контексте ребёнка, могли подставляться в общий семейный план.
- **План по ребёнку** (`member_id` = UUID ребёнка):
  - В пул попадают рецепты, где `recipes.member_id = этот UUID` **или** `recipes.member_id IS NULL` (семейные рецепты тоже доступны ребёнку).

Итог: для «Семья» пул = все рецепты пользователя из `public.recipes` с нужным `source`; для ребёнка — рецепты этого ребёнка + семейные.

### 2.2. Дальнейшая фильтрация кандидатов (в `pickFromPool`)

1. **Исключения:** уже выбранные в этот день/неделю `recipe_id` и нормализованные `title` (дедупликация).
2. **Тип приёма пищи (`meal_type`):**
   - Берётся из `recipes.meal_type` (нормализация: breakfast/lunch/snack/dinner, в т.ч. русские названия).
   - Если `meal_type` в БД `NULL` — определяется по названию/описанию/ингредиентам (токены: каша, омлет, суп, фрукты и т.д.).
   - В слот подставляется только рецепт с подходящим типом (например, в слот «завтрак» — только с resolved `breakfast`).
3. **Завтрак:** рецепты с «суп» в названии не подставляются на завтрак.
4. **Санity-правила:** тяжёлые блюда не на завтрак, супы не на полдник и т.д.
5. **Профиль (аллергии/предпочтения):** рецепты, содержащие ингредиенты из списка аллергий профиля, отбрасываются; учитываются предпочтения при скоринге.
6. **Скоринг:** оставшиеся кандидаты сортируются (разнообразие белков, источник и т.д.), случайный выбор среди топ-10.

Если после всех фильтров кандидатов для слота не остаётся — слот остаётся пустым (режим «только пул», без AI).

---

## 3. Сохранение сгенерированного в чате блюда в пул

Любое сгенерированное в чате блюдо должно иметь **тип приёма пищи** и **теги** и сохраняться в **`public.recipes`** (то есть в тот же пул).

### 3.1. Где сохраняется (call sites RPC create_recipe_with_steps)

Все создания рецепта идут через один RPC и **один канонический формат** (helper `canonicalizeRecipePayload`):

| Место | Файл / функция | Контекст |
|--------|----------------|----------|
| Чат | `supabase/functions/deepseek-chat/index.ts` — после ответа с рецептом | `source: "chat_ai"`, `sourceTag: "chat"` |
| Plan replace_slot (parsed) | `supabase/functions/generate-plan/index.ts` — создание рецепта из разобранного AI-ответа | `source: "chat_ai"`, `sourceTag: "plan"`, `contextMealType: mealType` слота |
| Plan replace_slot (firstRecipe) | `supabase/functions/generate-plan/index.ts` — создание из `aiData.recipes[0]` | то же |
| Plan week_ai | `supabase/functions/generate-plan/index.ts` — генерация недельного плана | `source: "week_ai"`, `sourceTag: "week_ai"`, `contextMealType: mealKey` |
| Клиент | `src/hooks/useRecipes.tsx` — `createRecipe` mutation | `source` из аргумента, `sourceTag`: `week_ai` или `chat` |

То есть запись всегда идёт в **`public.recipes`** через `create_recipe_with_steps` с payload, собранным из **канонического** helper (клиент: `src/utils/recipeCanonical.ts`, Edge: `supabase/functions/_shared/recipeCanonical.ts`).

### 3.2. Канонический формат: meal_type, tags, source

**Инвариант:** независимо от того, создаётся рецепт из Plan или Chat, запись в `public.recipes` имеет один и тот же формат: валидные `title`/`steps`/`ingredients`, всегда заполненный `meal_type`, консистентные `tags`, `source` из POOL_SOURCES.

- **meal_type** (всегда один из `breakfast` | `lunch` | `snack` | `dinner`), приоритет вывода:
  1. **mealType** — если передан и валидный, используется.
  2. **tags** — если в тегах есть строка вида `*_breakfast` / `*_lunch` / `*_snack` / `*_dinner` (префиксы `chat_`, `week_`, `plan_`), из неё берётся тип приёма.
  3. **contextMealType** — тип слота при создании из Plan/replace_slot (завтрак/обед/полдник/ужин).
  4. **fallback** — `"snack"`.

- **tags** (всегда массив, без дублей):
  - Обязательно присутствуют: **sourceTag** (`"chat"` | `"plan"` | `"week_ai"`) и **`${sourceTag}_${meal_type}`** (например `chat_breakfast`, `plan_lunch`, `week_ai_snack`).
  - Остальные теги из рецепта добавляются без дублирования.

- **source** — должен входить в POOL_SOURCES (`seed`, `starter`, `manual`, `week_ai`, `chat_ai`); иначе подставляется дефолтный AI-источник (`chat_ai`).

- **steps / ingredients** — гарантированно массивы; минимум один шаг (иначе ошибка); у ингредиентов обязательно есть `display_text` (при отсутствии собирается из `name` и при необходимости `amount`).

В итоге рецепт из чата и рецепт из replace_slot (Plan) попадают в пул с одинаковой структурой и всегда с заполненным `meal_type` и тегами; при replace_slot используется тип слота (`contextMealType`), а не fallback «snack».

---

## 4. Почему могли оставаться пустыми 3 слота (завтрак, обед, полдник)

Возможные причины до правок:

1. **План «Семья», а рецепты с контекстом ребёнка:** раньше в пул для «Семья» попадали только рецепты с `member_id IS NULL`. Если единственный сохранённый рецепт из чата был создан при выбранном ребёнке, у него `member_id = child`, и он не попадал в пул для семейного плана. **Сейчас** для «Семья» пул расширен до всех рецептов пользователя.
2. **Мало рецептов с нужным `meal_type`:** если в пуле почти нет рецептов с типом завтрак/обед/полдник (или они отфильтровались по аллергиям/sanity), слоты остаются пустыми. Имеет смысл проверять в БД: `SELECT id, title, meal_type, member_id, source FROM recipes WHERE user_id = '...' AND source IN ('seed','starter','manual','week_ai','chat_ai');`
3. **Отладка:** в запросе к `generate-plan` можно передать `debug_pool: true` и смотреть логи по каждому слоту (rejectReason, candidatesStrict/candidatesLoose, afterMealType и т.д.).

---

## 5. Кратко

| Вопрос | Ответ |
|--------|--------|
| Что такое пул? | Рецепты пользователя из таблицы **`public.recipes`** с `source IN ('seed','starter','manual','week_ai','chat_ai')`. |
| Как для профиля берётся блюдо? | Для «Семья» — все такие рецепты пользователя; для ребёнка — его рецепты + с `member_id IS NULL`. Дальше фильтр по типу приёма, аллергиям, sanity и скоринг. |
| Сохраняются ли блюда из чата в пул? | Да, в **`public.recipes`** через RPC `create_recipe_with_steps`, с **`meal_type`** и **тегами** (`chat`, `chat_<meal_type>`). |
